#!/usr/bin/env python3
"""
Hans tunnel setup – fill required values and generate .env for docker-compose.

Usage:
  python scripts/setup_hans.py
  python scripts/setup_hans.py -r c -s 192.168.1.100 --random-pass
  python scripts/setup_hans.py --role client --server 192.168.1.100

Run from the repo root. Creates .env in the current directory.
"""

from __future__ import print_function

import argparse
import getpass
import os
import secrets
import string
import sys


# Role shortcuts: number or single char -> server|client
ROLE_CHOICES = {
    "1": "server", "s": "server", "server": "server",
    "2": "client", "c": "client", "client": "client",
}


def parse_role(s):
    s = (s or "").strip().lower()
    return ROLE_CHOICES.get(s, None)


def generate_passphrase(length=24):
    """Generate a random passphrase (letters + digits + a few symbols)."""
    alphabet = string.ascii_letters + string.digits + "!@#$%&*"
    return "".join(secrets.choice(alphabet) for _ in range(length))


def main():
    parser = argparse.ArgumentParser(
        description="Fill required Hans tunnel options and write .env for docker-compose."
    )
    parser.add_argument(
        "-r", "--role",
        metavar="1|2|s|c",
        help="Role: 1 or s = server, 2 or c = client (default: prompt).",
    )
    parser.add_argument(
        "-p", "--passphrase",
        metavar="PHRASE",
        help="Passphrase (default: prompt; avoid passing on command line).",
    )
    parser.add_argument(
        "--random-pass", "--random-password",
        action="store_true",
        dest="random_pass",
        help="Generate a random passphrase (shown once; save it).",
    )
    parser.add_argument(
        "--pass-length",
        type=int,
        default=24,
        metavar="N",
        help="Length of random passphrase (default: 24).",
    )
    parser.add_argument(
        "-s", "--server",
        metavar="IP_OR_HOST",
        help="Server address (client only).",
    )
    parser.add_argument(
        "-n", "--network",
        metavar="NET",
        default="10.0.0.0",
        help="Tunnel network for server (default: 10.0.0.0).",
    )
    parser.add_argument(
        "-o", "--env",
        metavar="FILE",
        default=".env",
        dest="env",
        help="Output .env file path (default: .env).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print variables only, do not write .env.",
    )
    args = parser.parse_args()

    # --- Role ---
    role = None
    if args.role is not None:
        role = parse_role(args.role)
        if role is None:
            print("Invalid role. Use 1/s/server or 2/c/client.", file=sys.stderr)
            sys.exit(1)
    if not role:
        print("Role:  1 (or s) = server   2 (or c) = client")
        raw = input("Choice [2]: ").strip().lower() or "2"
        role = parse_role(raw)
        if role is None:
            role = "client"

    # --- Passphrase ---
    passphrase = args.passphrase
    if passphrase is None and args.random_pass:
        passphrase = generate_passphrase(max(12, min(64, args.pass_length)))
        print("Generated passphrase (save it; it won't be shown again):")
        print("  {}".format(passphrase))
    elif passphrase is None:
        use_random = input("Generate random passphrase? [y/N]: ").strip().lower()
        if use_random in ("y", "yes"):
            passphrase = generate_passphrase(args.pass_length)
            print("Generated passphrase (save it):")
            print("  {}".format(passphrase))
        else:
            passphrase = getpass.getpass("Passphrase: ")
            if not passphrase:
                print("Passphrase cannot be empty.", file=sys.stderr)
                sys.exit(1)
            passphrase_confirm = getpass.getpass("Passphrase (again): ")
            if passphrase != passphrase_confirm:
                print("Passphrases do not match.", file=sys.stderr)
                sys.exit(1)

    # --- Server (client only) ---
    server = args.server
    if role == "client" and not server:
        server = input("Server address (IP or hostname) [127.0.0.1]: ").strip() or "127.0.0.1"

    # --- Network (server) ---
    network = args.network
    if role == "server":
        network_in = input("Tunnel network [{}]: ".format(network)).strip()
        if network_in:
            network = network_in

    # --- Build .env content ---
    env_lines = [
        "# Generated by scripts/setup_hans.py – do not commit if it contains secrets",
        "HANS_PASSPHRASE={}".format(passphrase),
        "HANS_NETWORK={}".format(network),
        "HANS_ROLE={}".format(role),
    ]
    if role == "client":
        env_lines.insert(-1, "HANS_SERVER={}".format(server))

    content = "\n".join(env_lines) + "\n"

    if args.dry_run:
        print("Would write to {}:".format(args.env))
        print(content)
        return 0

    env_path = os.path.abspath(args.env)
    with open(env_path, "w") as f:
        f.write(content)
    print("Wrote {}".format(env_path))

    if role == "server":
        print("\nNext steps:")
        print("  docker compose build")
        print("  docker compose up hans-server -d")
        print("  (Server listens on tunnel network {}.)".format(network))
    else:
        print("\nNext steps:")
        print("  docker compose build")
        print("  docker compose up hans-client -d")
        print("  (Client connects to {}.)".format(server))

    return 0


if __name__ == "__main__":
    sys.exit(main())
